var documenterSearchIndex = {"docs":
[{"location":"ensembles/#Ensemble","page":"Ensembles","title":"Ensemble","text":"The Ensemble type provides a structured container for managing ensembles of model simulations. Each ensemble may consist of input parameters, styling metadata, ensemble variables and optional ensemble weights.","category":"section"},{"location":"ensembles/#Type-Definition","page":"Ensembles","title":"Type Definition","text":"mutable struct Ensemble <: AbstractEnsemble\n    N::Integer\n    path::Vector{String}\n    set::Vector{Integer}\n    p::DataFrames.DataFrame\n    s::DataFrames.DataFrame\n    w::Union{Array,AbstractEnsembleWeights}\n    v::Dict{Union{String,Symbol},Any}\nend\n\n","category":"section"},{"location":"ensembles/#Creating-an-Ensemble","page":"Ensembles","title":"Creating an Ensemble","text":"","category":"section"},{"location":"ensembles/#Manual-Construction","page":"Ensembles","title":"Manual Construction","text":"To construct an ensemble manually:\n\nens = Ensemble()\n\n# Populate fields\nens.N = 10\nens.path = [\"./ensemble1/member1\", \"./ensemble1/member2\", ...]\nens.set = fill(1, ens.N)\nens.p = DataFrame(param1 = rand(ens.N), param2 = rand(ens.N))\nens.s = DataFrame(color = [\"red\", \"blue\", ...])\nens.w = fill(1, ens.N) # Vector of weights for each ensemble member\nens.v[:temperature] = [temp1, temp2, ...]  # Vector of YAXArrays\n\nThis method gives you full control and is suitable for dynamically generated ensembles.\n\n","category":"section"},{"location":"ensembles/#From-Directory-Path","page":"Ensembles","title":"From Directory Path","text":"You can also load ensembles automatically using a directory path or a list of paths:\n\nens = Ensemble(\"path/to/ensemble1\")\nens = Ensemble([\"path/to/ens2a\", \"path/to/ens2b\"])","category":"section"},{"location":"ensembles/#Optional-Keyword-Arguments","page":"Ensembles","title":"Optional Keyword Arguments","text":"sort_by: Sort members using a column from the parameter DataFrame.\n\nThese constructors initialize the following fields:\n\nN, path, set, p, s\n\nRemaining fields (w, v) can be filled in later.\n\n","category":"section"},{"location":"ensembles/#Saving-an-Ensemble","page":"Ensembles","title":"Saving an Ensemble","text":"To save an ensemble to a JLD2 file:\n\nensemble_save(\"output_file.jld2\", ens, \"ens\")\n\noutput_file.jld2: Target file name.\nens: The ensemble to be saved.\n\"ens\": Key under which to store the ensemble in the file.\n\nUses JLD2.jldopen internally.\n\n","category":"section"},{"location":"ensembles/#Example-Workflow","page":"Ensembles","title":"Example Workflow","text":"# Initialize an ensemble from path\nens = Ensemble(\"runs/experiment1\")\n\n# Add variables\nensemble_get_var!(ens,\"lnd.nc\",\"smb\")\nensemble_get_var!(ens,\"atm.nc\",\"t2m\",newname=\"t2m_atm\")\n\n# Save to file\nensemble_save(\"output/ensemble_exp1.jld2\", ens, \"ens\")\n\n","category":"section"},{"location":"ensembles/#Notes","page":"Ensembles","title":"Notes","text":"Variables (v) are expected to be YAXArrays or collections thereof.\nWeights (w) may be a vector, array or a custom AbstractEnsembleWeights.\n\n","category":"section"},{"location":"ensembles/#Working-with-Ensembles:-a-basic-workflow","page":"Ensembles","title":"Working with Ensembles: a basic workflow","text":"This example demonstrates a typical workflow when working with ensembles in ModelAnalysis.jl: loading an ensemble from disk, attaching parameter metadata, loading model output variables, and creating subsets for analysis.\n\nThe intent is to show patterns rather than a single use case, so you can adapt the same steps to different ensembles, parameters, and diagnostics.\n\n","category":"section"},{"location":"ensembles/#1.-Defining-an-ensemble","page":"Ensembles","title":"1. Defining an ensemble","text":"An ensemble is usually defined by a directory that contains multiple model realizations (members). Each member corresponds to one model run, typically with different parameters or forcings.\n\n# Load an ensemble from a directory\nens = Ensemble(info.fldr)\n\nAt this point, the following information has been initialized:\n\nens.N is the number of ensemble members\nens.path stores the paths to each member\nens.p is a DataFrame holding parameters and metadata\nens.s is a DataFrame that can hold useful information for styles when plotting\n\n","category":"section"},{"location":"ensembles/#2.-Attaching-parameter-metadata","page":"Ensembles","title":"2. Attaching parameter metadata","text":"Often, parameters are known externally (e.g. from a design table or configuration file) and should be attached to the ensemble after loading.\n\nHere, we add two parameters:\n\nomp: number of OpenMP threads used in the run\ndx: horizontal grid spacing\n\nens.p[!, :omp] = info.omp\nens.p[!, :dx]  = info.dx\n\nThis makes the parameters first-class ensemble metadata and enables sorting, filtering, and grouping operations later on.\n\n","category":"section"},{"location":"ensembles/#3.-Loading-variables-from-model-output","page":"Ensembles","title":"3. Loading variables from model output","text":"Model output is typically stored in NetCDF files inside each ensemble member directory. So far, there is only one specialized routine for loading ensemble variables, which is done via ensemble_get_var!.\n\nensemble_get_var!(ens, \"timesteps.nc\", \"speed\")\nensemble_get_var!(ens, \"timesteps.nc\", \"dt_now\")\n\nAfter this step:\n\nens.v[:speed] contains the variable speed used in each run\nens.v[:dt_now] contains the variable dt_now used in each run\n\nThe exact structure (scalars, vectors, arrays) depends on the variable stored in the NetCDF file. But each member of ens.v is expected to be a vector of length ens.N, so one entry per ensemble member.\n\n","category":"section"},{"location":"ensembles/#4.-Sorting-an-ensemble","page":"Ensembles","title":"4. Sorting an ensemble","text":"Ensembles can be sorted by any parameter or derived quantity stored in ens.p.\n\nens = sort!(ens, :dx)\n\nThis is useful for visualization and for creating ordered subsets (e.g. from coarse to fine resolution).\n\n","category":"section"},{"location":"ensembles/#5.-Creating-subsets","page":"Ensembles","title":"5. Creating subsets","text":"There are several equivalent ways to create subsets of an ensemble, depending on what is most readable or convenient.","category":"section"},{"location":"ensembles/#5.1-Subsetting-by-parameter-values","page":"Ensembles","title":"5.1 Subsetting by parameter values","text":"Select all ensemble members with a grid spacing of dx = 16:\n\nens1 = ModelAnalysis.subset(ens, findall(ens.p[!, :dx] .== 16))\n\nThis approach is explicit and flexible when you need full control over the index selection.\n\n","category":"section"},{"location":"ensembles/#5.2-Subsetting-by-index-range","page":"Ensembles","title":"5.2 Subsetting by index range","text":"Select the first three ensemble members:\n\nens2 = ModelAnalysis.subset(ens, [1:3...])\n\nThis is mainly useful after sorting, when the ordering itself is meaningful.\n\n","category":"section"},{"location":"ensembles/#5.3-Filtering-with-a-predicate","page":"Ensembles","title":"5.3 Filtering with a predicate","text":"For more expressive, parameter-based selection, you can use filter with a predicate function:\n\nens3 = filter(p -> p.dx == 16, ens)\n\nThis style is often the most readable and scales well when multiple conditions are involved, for example:\n\nens_fine = filter(p -> p.dx ≤ 16 && p.omp ≥ 8, ens)\n\n","category":"section"},{"location":"ensembles/#6.-Summary","page":"Ensembles","title":"6. Summary","text":"A typical ensemble analysis workflow therefore looks like:\n\nLoad ensemble structure from disk\nLoad variables from model output\nSort and subset the ensemble as needed\nPerform analysis or visualization on selected subsets\n\nThis separation between structure, metadata, and data is deliberate and helps keep ensemble analyses reproducible and easy to extend.","category":"section"},{"location":"modelanalysis-api/#ModelAnalysis-API","page":"API","title":"ModelAnalysis API","text":"","category":"section"},{"location":"modelanalysis-api/#ModelAnalysis.Colorbar_logdiff!-Tuple{Any, Any}","page":"API","title":"ModelAnalysis.Colorbar_logdiff!","text":"Colorbar_logdiff!(fig_now,hmpos)\n\nTBW\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.clean-Tuple{Any}","page":"API","title":"ModelAnalysis.clean","text":"Clean a variable, so that:\n\nmissing values are replaced with NaNs \nvalues outside of mask are set to NaN \nvalues outside of desired range are set to limits or NaN\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.contour3D_ice2D_topo!-NTuple{4, Any}","page":"API","title":"ModelAnalysis.contour3D_ice2D_topo!","text":"Add surface elevation or ice thickness contours to a predefined axis. \n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.contour_ice2D_bath!-NTuple{4, Any}","page":"API","title":"ModelAnalysis.contour_ice2D_bath!","text":"Add bathymetry contours to a predefined axis. \n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.contour_ice2D_topo!-NTuple{4, Any}","page":"API","title":"ModelAnalysis.contour_ice2D_topo!","text":"Add surface elevation or ice thickness contours to a predefined axis. \n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.heatmap_ice2D_bathymetry!-NTuple{4, Any}","page":"API","title":"ModelAnalysis.heatmap_ice2D_bathymetry!","text":"Add bathymetry shading to a predefined axis.  By default, greyshading used, with dark at z=colorrange[1] to white at z=colorrange[2]. z_bed should be modified externally before using this routine (masking, etc) to facilitate making animations.\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.heatmapclip!-Tuple","page":"API","title":"ModelAnalysis.heatmapclip!","text":"heatmapclip!(args...; scale=identity, colorrange=nothing, colormap=nothing, tol=1e-6, kwargs...)\n\nCreate a heatmap with automatic clipping indicators on the colorbar.\n\nThis function extends Makie.heatmap! by automatically setting lowclip and highclip  colors when data values fall outside the specified colorrange. Clipped values are  indicated by colored triangles at the ends of the colorbar using the first and last  colors of the colormap.\n\nArguments\n\nargs...: Positional arguments matching any heatmap! signature:\nheatmapclip!(ax, z): Plot matrix z on axis ax\nheatmapclip!(ax, x, y, z): Plot matrix z with coordinates x, y on axis ax\n\nKeywords\n\nscale=identity: Function to transform data values (e.g., log10, sqrt). Applied to  both z and colorrange.\ncolorrange=nothing: Tuple (low, high) defining the color scale limits. If nothing,  defaults to (minimum(z), maximum(z)) (excluding NaN values).\ncolormap=nothing: Colormap to use. If nothing, defaults to ColorSchemes.roma.\ntol=1e-6: Tolerance for determining if data extends beyond colorrange. Values below  colorrange[1] - tol trigger lowclip; values above colorrange[2] + tol trigger highclip.\nkwargs...: Additional keyword arguments passed to heatmap!.\n\nReturns\n\nReturns the heatmap plot object hm\n\nExamples\n\nusing CairoMakie, ColorSchemes\n\n# Basic usage with automatic clipping\nz = randn(20, 20) # data range ±3\nfig = Figure(); ax = Axis(fig[1, 1])\nhm = heatmapclip!(ax, z, colorrange=(-1, 1))\nColorbar(fig[1, 2],hm)\nfig\n\n# To see automatic clipping changes,\n# change colorrange:\ncolorrange=(-4, 1) # no lowclip\ncolorrange=(-1, 4) # no highclip\ncolorrange=(-4, 4) # no lowclip or highclip\n\nNotes\n\nNaN values in z are automatically excluded when computing data range\nClipping indicators only appear when data actually extends beyond colorrange (within tol)\nThe scale transformation is applied after clipping detection. It is applied both to z and colorrange\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.preprocess_ice2D_variable-Tuple{Any}","page":"API","title":"ModelAnalysis.preprocess_ice2D_variable","text":"Preprocess variable for plotting\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.print_row-Tuple{Any}","page":"API","title":"ModelAnalysis.print_row","text":"Print a row of data transposed\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.Ensembles.Ensemble-NTuple{6, Any}","page":"API","title":"ModelAnalysis.Ensembles.Ensemble","text":"Ensemble(args...; sort_by=\"\")\n\nCreate an Ensemble object, which stores simulation members, paths, and associated metadata.\n\nConstruction Methods\n\nFrom explicit components:\n\nEnsemble(N, path, set, p, s, v)\n\nN::Int: Number of ensemble members.\npath::Vector{String}: Paths to simulations.\nset::Vector{Int}: Indicates which ensemble set each member belongs to.\np::DataFrame: Ensemble info table.\ns::DataFrame: Plotting parameters table.\nv: Optional additional data. This constructor sets internal weights to nothing and stores v.\n\nFrom a single ensemble directory:\n\nEnsemble(ens_path::String; sort_by=\"\")\n\nens_path: Path to the ensemble directory or single simulation.\nsort_by: Optional column name in the info table to sort the members.\n\nFrom multiple ensemble directories:\n\nEnsemble(ens_path::Vector{String}; sort_by=\"\")\n\nens_path: Vector of paths to ensemble directories.\nsort_by: Optional column name to sort the combined members.\n\nReturns\n\nAn Ensemble object containing:\n\nN: Number of members.\npath: Vector of paths to simulations.\nset: Vector indicating the set of each member.\np: DataFrame with ensemble info.\ns: DataFrame with plotting parameters.\nweights: Optional weights or nothing.\nv: Optional additional data.\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.Ensembles.collect_variable-Tuple{AbstractEnsemble, Symbol, Symbol}","page":"API","title":"ModelAnalysis.Ensembles.collect_variable","text":"collect_variable(ens::AbstractEnsemble, domain::Symbol, var::Symbol; default=missing)\n\nCollects a specified variable var from the given domain across all model members in an ensemble ens.\n\nArguments\n\nens::AbstractEnsemble: An ensemble object containing multiple model members.\ndomain::Symbol: The domain key within each model run (e.g., :atm, :ocn) from which to extract the variable.\nvar::Symbol: The variable key to collect (e.g., :t2m, :sst).\ndefault: Optional keyword argument specifying the value to use if the variable var is not present in a particular model run’s domain dictionary. Defaults to missing.\n\nReturns\n\nA vector where each element corresponds to the value of var in the specified domain for each model run in the ensemble. If a model run does not contain the variable, the default value is used instead.\n\nExample\n\nt2m_values = collect_variable(ensemble, :atm, :t2m)\nsst_values = collect_variable(ensemble, :ocn, :sst; default=nothing)\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.Ensembles.ensemble_init-Tuple{String}","page":"API","title":"ModelAnalysis.Ensembles.ensemble_init","text":"ensemble_init(ens_path::String;sort_by=\"\",verbose=true)\n\nInitialize an ensemble from a directory path. Reads info.txt if present to build a DataFrame of ensemble members; otherwise assumes a single simulation. Returns a tuple (N, path, set, p, s) with the number of members, paths to each simulation, a placeholder integer array, the ensemble info DataFrame, and a DataFrame of plotting parameters. Optionally sorts the ensemble by a column in the info DataFrame if sort_by is given. Prints summary information if verbose is true.\n\n\n\n\n\n","category":"method"},{"location":"modelanalysis-api/#ModelAnalysis.Ensembles.ensemble_init-Tuple{Vector{String}}","page":"API","title":"ModelAnalysis.Ensembles.ensemble_init","text":"ensemble_init(ens_path::Vector{String};sort_by=\"\",verbose=true)\n\nInitialize an ensemble from multiple directories. Calls the single-path ensemble_init for each entry in ens_path and combines the results, returning a tuple (N, path, set, p, s)     with the total number of members, paths to all simulations, a vector indicating which set     each member belongs to, a combined ensemble info DataFrame, and a combined plotting parameters     DataFrame. Optionally sorts all members by a column in the DataFrame if sort_by is given.     Prints a summary if verbose is true.\n\n\n\n\n\n","category":"method"},{"location":"#ModelAnalysis.jl-Documentation","page":"Home","title":"ModelAnalysis.jl Documentation","text":"","category":"section"},{"location":"#ModelAnalysis.jl","page":"Home","title":"ModelAnalysis.jl","text":"Tools for analysing model output in Julia.","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"using Pkg\nPkg.add(\"ModelAnalysis\")","category":"section"},{"location":"#Quick-example","page":"Home","title":"Quick example","text":"using ModelAnalysis\n\n# example usage here\n\nTO DO","category":"section"},{"location":"plotting-with-makie/#Plotting-with-Makie","page":"Plotting with Makie","title":"Plotting with Makie","text":"","category":"section"},{"location":"plotting-with-makie/#Heatmap-functions","page":"Plotting with Makie","title":"Heatmap functions","text":"heatmapclip, heatmapclip!\n\nBasic usage with automatic clipping:\n\nusing CairoMakie\n\nbegin\n    # To see automatic clipping changes, change colorrange:\n    colorrange = (-1, 1) # lowclip and highclip\n    colorrange = (-4, 1) # no lowclip\n    colorrange = (-1, 4) # no highclip\n    colorrange = (-4, 4) # no lowclip or highclip\n    \n    z = randn(20, 20) # data range ±3\n    fig = Figure(); ax = Axis(fig[1, 1])\n    hm = heatmapclip!(ax, z, colorrange=colorrange)\n    Colorbar(fig[1, 2],hm)\n    fig\nend\n\nAdditionally use the scale argument to scale both z and the colorrange values, so that the Colorbar is consistent with the data plotted.\n\nusing CairoMakie\n\nbegin\n    z = rand(20, 20) .* 100\n    fig = Figure(); ax = Axis(fig[1, 1])\n    hm = heatmapclip!(ax, z, colorrange=(1,10), scale=log10)\n    Colorbar(fig[1, 2],hm)\n    fig\nend\n","category":"section"}]
}
