
module Ensembles

import DataFrames
import CSV

using JLD2
using YAXArrays
using NCDatasets
using NetCDF
using Statistics

using Colors
using ColorSchemes

export AbstractModel
export AbstractModelVariables
export AbstractEnsemble
export AbstractEnsembleWeights
export Ensemble
export ensemble_init
export ensemble_save
export ensemble_sort!
export ensemble_linestyling!
export ensemble_get_var!
export ens_stat
export ensemble_members
export collect_variable

abstract type AbstractModel end
abstract type AbstractModelVariables end

abstract type AbstractEnsemble end
abstract type AbstractEnsembleWeights end

mutable struct Ensemble <: AbstractEnsemble 
    N::Integer
    path::Vector{String}                        # member path (path to each member of ensemble)
    set::Vector{Integer}                        # which set did member come from (corresponding to ensemble base paths)
    p::DataFrames.DataFrame                     # info/parameters
    s::DataFrames.DataFrame                     # styles
    w::Union{Array,AbstractEnsembleWeights}     # Ensemble weights

    # variables, preferrably each variable a YAXArray with one dimension N,
    # or a vector of length N of YAXArrays
    v::Dict{Union{String,Symbol},Any}
end

function ensemble_init(ens_path::String;sort_by::String="",verbose=true)   
    
    # Check if ens_path exists
    if !ispath(ens_path)
        error(string("Ensemble::ensemble_init:: Error: path not found: ",ens_path))
    end

    # Define the info filename for an ensemble of simulations
    fname = joinpath(ens_path,"info.txt")

    # Read the ensemble info table into a DataFrame format, if it exists
    if isfile(fname)
        # This is an ensemble, generated by runme. Load the info
        p  = CSV.read(fname,DataFrames.DataFrame,delim=' ',ignorerepeated=true,header=1)
        found_info = true
    else 
        # This is probably a single simulation, so no info file is available.
        # Generate something simple.
        rundir = splitpath(ens_path)[end]
        p = DataFrames.DataFrame("runid"=>1,"rundir"=>rundir)
        found_info = false
    end
    
    # Print parameters/info
    println(p)

    N = DataFrames.nrow(p) 
    
    # Initialize an empty array of the right length
    set = fill(1,N)
    path = fill("",N)
    
    # Populate the array
    if found_info
        # Ensemble, populate the run path by combing path with rundir
        for i in 1:N
            path[i] = joinpath(ens_path,string(p[i,"rundir"]))
        end
    else
        # Single simulation, set the simulation path equal to the ensemble path
        for i in 1:N
            path[i] = ens_path
        end
    end

    s = DataFrames.DataFrame()
    s.valid = fill(true,N)
    s.label = fill("",N)
    s.color = fill(colorant"Black",N)
    s.linewidth = fill(1,N)
    s.linestyle = fill(:solid,N)
    s.markersize = fill(1,N) 

    # Add a weights vector too
    w = fill(1.0,N)

    # Sort the ensemble by a given parameter if desired
    if sort_by != ""
        kk = sortperm(p[!,sort_by])
        path  = path[kk]
        set   = set[kk]
        p     = p[kk,:]
        s     = s[kk,:]
        w     = w[kk]
    end
    
    if verbose
        println("Defined ensemble, number of members: ",N)
        println("Ensemble path: $ens_path")
    end

    return N, path, set, p, s, w

end

function ensemble_init(ens_path::Vector{String};sort_by::String="",verbose=true)   
    
    # Define the ensemble components based on first ensemble set of interest
    _, path, set, p, s, w = ensemble_init(ens_path[1];verbose=false)

    # Define info array for entire list 
    for j = 2:size(ens_path,1)

        _, path1, set1, p1, s1, w1 = ensemble_init(ens_path[j];verbose=false)
        set .= j 

        append!(path,path1)
        append!(set,set1)
        p = vcat(p,p1; cols=:union)     # Handle joining DataFrames using vcat, in case columns are not the same...
        s = vcat(s,s1; cols=:union)     # Handle joining DataFrames using vcat, in case columns are not the same...
        append!(w,w1)
    end
    
    # Update the total number of simulations and number of ensemble sets 
    N = DataFrames.nrow(p) 

    # Sort the ensemble by a given parameter if desired
    if sort_by != ""
        kk = sortperm(p[!,sort_by])
        path  = path[kk]
        set   = set[kk]
        p     = p[kk,:]
        s     = s[kk,:]
        w     = w[kk]
    end
    
    if verbose
        println("Defined ensemble, number of members: ",N)
        println("Ensemble path(s):")
        for j = 1:size(ens_path,1)
            println("  ",ens_path[j])
        end
    end

    return N, path, set, p, s, w
end

function Ensemble(ens_path::String;sort_by::String="")   
    
    N, path, set, p, s, w = ensemble_init(ens_path;sort_by=sort_by)

    # Store all information for output in the ensemble object
    ens = Ensemble(N,path,set,p,s,w,Dict())

    return ens
end

function Ensemble(ens_path::Vector{String};sort_by::String="")   
    
    N, path, set, p, s, w = ensemble_init(ens_path;sort_by=sort_by)

    # Store all information for output in the ensemble object
    ens = Ensemble(N,path,set,p,s,w,Dict())

    return ens
end

function ensemble_sort!(ens::AbstractEnsemble,sort_by::String)

    kk = sortperm(ens.p[!,sort_by])
    ens.path = ens.path[kk]
    ens.set  = ens.set[kk]
    ens.p    = ens.p[kk,:]
    ens.s    = ens.s[kk,:]
    ens.w    = ens.w[kk]
    
    # Add sorting of each entry of Dictionaries v and vector m, entries of which should be vectors of length N
    if length(ens.v) != 0 | length(ens.m) != 0
        warning("""Ensemble .v or .m component is not empty, but sorting of variables is not yet implemented.
        In this case, the newly sorted ensemble metadata will not match the order of the variable entries.
        For now, ensemble sorting should be applied before loading any variables or members.""")
    end

    return
end

# Save an ensemble to a file using JLD2 but give it a user-defined name for loading later
function ensemble_save(filename::String,ens::AbstractEnsemble,name::String)

    #@save fileout ens
    JLD2.jldopen(filename, "w") do file
        file[name] = ens  # Save the ensemble with the desired name
    end
    println("Saved $filename")

    return
end

function ensemble_linestyling!(ens::AbstractEnsemble;cat_col=nothing,cat_style=nothing,cat_width=nothing,
                                            colors=:tab10,linestyle=:solid,linestyle2=(:solid,:normal),linewidth=1)

    # Set default style options
    ens.s.color      = fill(colorant"Black",ens.N)
    ens.s.linestyle  = fill(linestyle,ens.N)
    ens.s.linestyle2 = fill(linestyle2,ens.N)
    ens.s.linewidth  = fill(linewidth,ens.N)

    if !isnothing(cat_col)
        # Determine unique values of distinguishing variable cat_col
        vals = unique(ens.p[!,cat_col])
    
        # Generate the colormap for these values
        #col_map = CairoMakie.cgrad(colors,vals);        
        col_map = get(colorschemes[colors], range(0.0, 1.0, length=length(vals))) |> ColorScheme

        for (i,val) in enumerate(vals)
            kk = findall(ens.p[!,cat_col] .== val)
            ens.s.color[kk] .= col_map[i]
        end
    
    end

    if !isnothing(cat_style) 
        # Get line styles

        # These linestyles are also created in src/Plots.jl, but convenient to do so explicitly here
        gapstyles  = [:normal, :dense, :loose, 10]
        linestyles0 = [:dot, :dash, :dashdot, :dashdotdot]
        linestyles2 = vec([(ls, gs) for ls in linestyles0, gs in gapstyles])
        linestyles2 = vcat([(:solid,:normal)],linestyles2)

        vals = unique(ens.p[!,cat_style])

        for (i,val) in enumerate(vals)
            kk = findall(ens.p[!,cat_style] .== val)
            ens.s.linestyle2[kk] .= Ref(linestyles2[i])
        end
    end
    
    if !isnothing(cat_width) 
        # Get line widths

        # TO DO

        vals = unique(ens.p[!,cat_width])
    end

    return
end

function ensemble_get_var(paths::Vector{String},filename::String,varname::String;scale=1.0)::Vector{Any}

    # Get total number of ensemble members
    N = size(paths,1)

    println("\nLoad $varname from $filename")
    println("  Number of members: $N")

    # Make an empty array to hold the variable 
    vars = []

    # Load time and variable from each simulation in ensemble 
    for k in 1:N 

        # Get path of file of interest for reference sim
        path_now = joinpath(paths[k],filename)

        if isfile(path_now)
            # Data file was found, proceed to load variable

            # Check if variable exists 
            # (use NCDataset interface due to possible error with YAXArrays on _ts files)
            ds = NCDataset(path_now)
            if !haskey(ds, varname)
                NetCDF.close(ds)
                error("load_var:: Error: variable $(varname) not found in file:\n    $(path_now)")
            end
            NCDatasets.close(ds)

            var_now = nothing  # Declare in outer scope

            try
                # Try to open with YAXArrays (lazy by default)
                ds = open_dataset(path_now, driver = :netcdf)

                # Read a YAXArray and load it into memory
                var_now = readcubedata(ds[varname])

            catch err
                # Build a YAXArray manually
                #@warn "YAXArrays failed: falling back to NCDataset" err

                # Open with NCDatasets.jl
                ds_nc = NCDataset(path_now)

                # Extract the variable data
                data = ds_nc[varname][:]
                dnames = Symbol.(NCDatasets.dimnames(ds_nc[varname]))  # Tuple of dimension names
                axes = [ds_nc[d][:] for d in dnames]

                # Create Dim objects
                dims = Tuple(Dim{name}(axis) for (name, axis) in zip(dnames, axes))

                # Wrap into YAXArray
                var_now = YAXArray(dims,data)

                # Close file connection
                NCDatasets.close(ds_nc)
            end

            # Scale variable as desired 
            var_now .= var_now .* scale
        
        else
            # File was not found, assume it should be stored as nothing

            var_now = nothing

        end

        # Store variable in output array
        push!(vars, var_now)

    end

    # Return a vector of variables of length of ensemble
    return vars
end

function ensemble_get_var!(ens::AbstractEnsemble,filename::String,varname::String;newname=nothing,scale=1.0)

    # Set how the variable will be saved
    if isnothing(newname) 
        newname = varname
    end

    # Load the vector of ensemble data
    vars = ensemble_get_var(ens.path,filename,varname;scale=scale)
        
    # Store in ensemble struct
    ens.v[newname] = vars

    return
end

function ens_stat(var::Vector{Any},stat::Function)

    vals = fill(NaN,ens.N)

    for j = 1:ens.N
        vals[j] = stat(var[j])
    end

    return vals
end

# Function to specifically return the ensemble members struct itself
# (defined generally for the AbstractModel, but can be custom defined for specific models)
ensemble_members(ens::AbstractEnsemble) = ens.m
ensemble_members(ens::Ensemble) = error("This ensemble type does not define explicit members.")

"""
    collect_variable(ens::AbstractEnsemble, domain::Symbol, var::Symbol; default=missing)

Collects a specified variable `var` from the given `domain` across all model members in an ensemble `ens`.

# Arguments
- `ens::AbstractEnsemble`: An ensemble object containing multiple model members.
- `domain::Symbol`: The domain key within each model run (e.g., `:atm`, `:ocn`) from which to extract the variable.
- `var::Symbol`: The variable key to collect (e.g., `:t2m`, `:sst`).
- `default`: Optional keyword argument specifying the value to use if the variable `var` is not present in a particular model runâ€™s domain dictionary. Defaults to `missing`.

# Returns
- A vector where each element corresponds to the value of `var` in the specified `domain` for each model run in the ensemble.
  If a model run does not contain the variable, the `default` value is used instead.

# Example
```julia
t2m_values = collect_variable(ensemble, :atm, :t2m)
sst_values = collect_variable(ensemble, :ocn, :sst; default=nothing)
"""
function collect_variable(ens::AbstractEnsemble,
                          domain::Symbol, var::Symbol;
                          default = missing)
    
    members = ensemble_members(ens)
    [ let dom = getfield(member, domain)
          haskey(dom, var) ? dom[var] : default
      end
      for member in members ]
end

end # module